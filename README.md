# 寄存器版，点亮LED
## 直接找出地址，进行地址访问
### eg:
“	*( ungigned int *)(0x40021400+0x00) &=~(3<<(2*6));/*&之前的操作，使目标的两个位为1，其他位为0，然后取反，目标位为0，其他位为1，与原来的与操作后，目标位为0,其他位1 */”

像此类操作，对寄存器的地址直接进行操作，未进行任何封装

#### 操作流程：
1. 打开keil，完成对应stm型号配置
2. 添加文件：.c .h startup启动文件等等
3. 找到原理图中对应的外设gpio，在手册中找到对应外设的地址
4. 对多个寄存器的地址内容进行操作，完成点亮
5. 注：配置时钟，每个外设都有时钟进行控制，为降低功耗，默认是时钟关闭，
   复位和时钟控制RCC，根据外设的总线找到对应的寄存器，打开时钟

## 使用C语言进行宏定义
### eg:
#define GPIO_MODER  *(unsigned int *)( GPIO_BASE+0X00)

GPIO_MODER &=~(3<<(2*6));使用宏定义，增强可读性，可操作性

#### 操作流程

1. 完成同上的配置，.h文件中完成宏定义
2. 开gpio外设的时钟
3. 配置gpio为输出模式
4. 让gpio输出0/1

# 优缺点：
## 缺点：
可读性差：

直接操作寄存器通常需要了解硬件的详细信息，这使得代码的可读性和可理解性降低。对于不熟悉硬件细节的开发者来说，理解这样的代码可能会很困难。

可移植性差：

使用寄存器编程通常与特定的硬件紧密相关，这意味着代码的可移植性较差。如果硬件平台发生变化，可能需要大量修改代码。

开发效率低：

使用寄存器编程需要开发者手动管理硬件资源，这可能会增加开发时间和出错的可能性。相比之下，库函数通常提供了更高层次的抽象，可以提高开发效率。

维护困难：

由于代码的可读性和可移植性较差，维护和调试这样的代码可能会更加困难。任何修改都可能需要深入了解硬件细节。

错误风险高：

直接操作寄存器容易出错，例如写入错误的值或在不正确的时间访问寄存器，这可能导致系统不稳定或崩溃。

缺乏抽象：

库函数通常提供了更高层次的抽象，隐藏了硬件的复杂性，使得开发者可以更专注于应用逻辑而不是硬件细节。直接操作寄存器则缺乏这种抽象。

## 优点：

性能优化：

直接操作寄存器可以提供更高的性能，因为省去了库函数调用的开销。

资源受限的环境：

在资源非常受限的嵌入式系统中，直接操作寄存器可以减少代码大小和内存占用。

硬件控制需求：

对于需要精确控制硬件的应用，直接操作寄存器可能是必要的。


